<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="x-icon" href="../game-icon/path-finder.png">
    <title>Pixel Pathfinder</title>
    <style>
        :root {
            --bg-color: #0f0f12;
            --surface: #1a1a23;
            --primary: #6e45e2;
            --primary-light: #8d6eff;
            --secondary: #ff7e5f;
            --error: #ff4d6d;
            --success: #4ade80;
            --text: #f0f0f5;
            --text-secondary: #b0b0bf;
            --wall: #3a3a4a;
            --pixel-size: 4px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            touch-action: manipulation;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
            image-rendering: pixelated;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            position: relative;
        }

        h1 {
            color: var(--primary-light);
            margin-bottom: 10px;
            font-size: 3rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 
                0 0 10px rgba(110, 69, 226, 0.5),
                0 0 20px rgba(110, 69, 226, 0.3);
            position: relative;
            z-index: 2;
        }

        h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: var(--pixel-size);
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            background-color: var(--surface);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 
                0 8px 20px rgba(0, 0, 0, 0.5),
                inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(135deg, transparent 48%, rgba(110, 69, 226, 0.1) 49%, rgba(110, 69, 226, 0.1) 51%, transparent 52%),
                linear-gradient(-135deg, transparent 48%, rgba(110, 69, 226, 0.1) 49%, rgba(110, 69, 226, 0.1) 51%, transparent 52%);
            background-size: 20px 20px;
            opacity: 0.3;
            z-index: -1;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-info span {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text);
            display: flex;
            align-items: center;
        }

        .game-info span::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }

        .level-info::before {
            background-color: var(--primary);
        }

        .moves-info::before {
            background-color: var(--secondary);
        }

        .maze-container {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
            overflow: hidden;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 0, 0, 0.3);
            touch-action: none;
        }

        .maze {
            display: grid;
            width: 100%;
            aspect-ratio: 1/1;
            max-width: 600px;
            margin: 0 auto;
        }

        .cell {
            position: relative;
            background-color: var(--surface);
            border: 1px solid rgba(255, 255, 255, 0.03);
            transition: 
                background-color 0.3s ease,
                transform 0.2s ease;
        }

        .cell.wall {
            background-color: var(--wall);
            animation: wall-pulse 3s infinite;
        }

        @keyframes wall-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.9; }
        }

        .cell.start {
            background-color: var(--success);
            z-index: 2;
            animation: start-pulse 1.5s infinite alternate;
        }

        @keyframes start-pulse {
            from { box-shadow: inset 0 0 0 2px rgba(74, 222, 128, 0.5); }
            to { box-shadow: inset 0 0 0 6px rgba(74, 222, 128, 0.3); }
        }

        .cell.end {
            background-color: var(--error);
            z-index: 2;
            animation: end-pulse 1.5s infinite alternate;
        }

        @keyframes end-pulse {
            from { box-shadow: inset 0 0 0 2px rgba(255, 77, 109, 0.5); }
            to { box-shadow: inset 0 0 0 6px rgba(255, 77, 109, 0.3); }
        }

        .cell.path {
            background-color: rgba(110, 69, 226, 0.3);
        }

        .cell.visited {
            background-color: rgba(255, 126, 95, 0.15);
        }

        .cell.current {
            background-color: var(--primary-light);
            z-index: 3;
            transform: scale(0.9);
            animation: current-glow 1.5s infinite alternate;
        }

        @keyframes current-glow {
            from { box-shadow: 0 0 5px var(--primary-light); }
            to { box-shadow: 0 0 15px var(--primary-light); }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            width: 100%;
            margin-top: 20px;
        }

        .btn {
            position: relative;
            background-color: var(--surface);
            color: var(--text);
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: 0.5s;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-secondary {
            background-color: var(--secondary);
            color: white;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            width: 200px;
            height: 200px;
            margin-top: 20px;
            position: relative;
        }

        .mobile-btn {
            background-color: rgba(110, 69, 226, 0.3);
            border: 2px solid var(--primary);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text);
            font-size: 1.5rem;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            transition: all 0.2s ease;
        }

        .mobile-btn:active {
            background-color: var(--primary);
            transform: scale(0.95);
        }

        .mobile-btn.up {
            grid-column: 2;
            grid-row: 1;
        }

        .mobile-btn.down {
            grid-column: 2;
            grid-row: 3;
        }

        .mobile-btn.left {
            grid-column: 1;
            grid-row: 2;
        }

        .mobile-btn.right {
            grid-column: 3;
            grid-row: 2;
        }

        .mobile-center {
            grid-column: 2;
            grid-row: 2;
            background-color: transparent;
            border: none;
            pointer-events: none;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background-color: var(--surface);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 
                0 10px 25px rgba(0, 0, 0, 0.5),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            text-align: center;
            z-index: 100;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 90%;
            width: 400px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .message h2 {
            color: var(--primary-light);
            margin-bottom: 15px;
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .message p {
            margin-bottom: 25px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 99;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
            max-width: 600px;
        }

        .key-hint {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 2px;
            min-width: 20px;
            font-family: monospace;
        }

        /* Swipe instructions for mobile */
        .swipe-hint {
            display: none;
            margin-top: 10px;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Pixel art decorations */
        .pixel-decoration {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: var(--primary);
            opacity: 0.3;
            z-index: 0;
        }

        .decoration-1 {
            top: 10%;
            left: 5%;
            animation: float 6s infinite ease-in-out;
        }

        .decoration-2 {
            top: 30%;
            right: 8%;
            animation: float 8s infinite ease-in-out 1s;
        }

        .decoration-3 {
            bottom: 20%;
            left: 10%;
            animation: float 7s infinite ease-in-out 2s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .game-info span {
                font-size: 0.9rem;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
            }

            .btn {
                width: 100%;
                padding: 12px;
            }

            .message {
                width: 90%;
                padding: 20px;
            }

            .message h2 {
                font-size: 1.5rem;
            }

            /* Show mobile controls on small screens */
            .mobile-controls {
                display: grid;
            }

            .swipe-hint {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="pixel-decoration decoration-1"></div>
    <div class="pixel-decoration decoration-2"></div>
    <div class="pixel-decoration decoration-3"></div>

    <header>
        <h1>Pixel Pathfinder</h1>
    </header>

    <div class="game-container">
        <div class="game-info">
            <span class="level-info">Level: <span id="level">1</span>/10</span>
            <span class="moves-info">Moves: <span id="moves">0</span></span>
        </div>

        <div class="maze-container" id="maze-container">
            <div class="maze" id="maze"></div>
        </div>

        <div class="mobile-controls" id="mobile-controls">
            <div class="mobile-btn up" id="up-btn">↑</div>
            <div class="mobile-btn down" id="down-btn">↓</div>
            <div class="mobile-btn left" id="left-btn">←</div>
            <div class="mobile-btn right" id="right-btn">→</div>
            <div class="mobile-center"></div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="reset">Reset</button>
            <button class="btn btn-secondary" id="solve">Show Path</button>
        </div>

        <div class="instructions">
            Use <span class="key-hint">WASD</span> or <span class="key-hint">↑↓←→</span> keys to move from <span style="color: var(--success)">start</span> 
            to <span style="color: var(--error)">end</span>. Avoid <span style="color: var(--wall)">walls</span>.
            <div class="swipe-hint">Or swipe on the maze to move</div>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="message" id="message">
        <h2 id="message-title">Level Complete!</h2>
        <p id="message-text">You solved the maze in 0 moves!</p>
        <button class="btn btn-primary" id="next-level">Next Level</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state
            const gameState = {
                level: 1,
                moves: 0,
                maze: [],
                start: { x: 0, y: 0 },
                end: { x: 0, y: 0 },
                current: { x: 0, y: 0 },
                size: 8,
                path: [],
                visited: new Set(),
                solution: [],
                solving: false,
                keyState: {},
                touchStart: null
            };

            // DOM elements
            const mazeElement = document.getElementById('maze');
            const mazeContainer = document.getElementById('maze-container');
            const levelElement = document.getElementById('level');
            const movesElement = document.getElementById('moves');
            const resetButton = document.getElementById('reset');
            const solveButton = document.getElementById('solve');
            const messageElement = document.getElementById('message');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const nextLevelButton = document.getElementById('next-level');
            const overlay = document.getElementById('overlay');
            const upBtn = document.getElementById('up-btn');
            const downBtn = document.getElementById('down-btn');
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');

            // Key codes for movement
            const KEY_CODES = {
                UP: ['ArrowUp', 'KeyW'],
                DOWN: ['ArrowDown', 'KeyS'],
                LEFT: ['ArrowLeft', 'KeyA'],
                RIGHT: ['ArrowRight', 'KeyD']
            };

            // Initialize game
            initGame();

            // Event listeners
            resetButton.addEventListener('click', initGame);
            solveButton.addEventListener('click', showSolution);
            nextLevelButton.addEventListener('click', nextLevel);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Mobile controls
            upBtn.addEventListener('touchstart', () => movePlayer(0, -1));
            downBtn.addEventListener('touchstart', () => movePlayer(0, 1));
            leftBtn.addEventListener('touchstart', () => movePlayer(-1, 0));
            rightBtn.addEventListener('touchstart', () => movePlayer(1, 0));
            
            // Touch events for swipe controls
            mazeContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            mazeContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            mazeContainer.addEventListener('touchend', handleTouchEnd);

            // Initialize game
            function initGame() {
                gameState.moves = 0;
                gameState.visited = new Set();
                gameState.path = [];
                gameState.solving = false;
                
                updateLevelInfo();
                generateMaze();
                renderMaze();
            }

            // Generate maze based on level
            function generateMaze() {
                // Set maze size based on level (8x8 to 20x20)
                gameState.size = Math.min(8 + Math.floor(gameState.level * 1.2), 20);
                
                // Initialize empty maze
                gameState.maze = Array(gameState.size).fill().map(() => Array(gameState.size).fill(0));
                
                // Set start and end positions (always in opposite corners)
                gameState.start = { x: 0, y: 0 };
                gameState.end = { x: gameState.size - 1, y: gameState.size - 1 };
                gameState.current = { ...gameState.start };
                
                // Generate walls based on level difficulty
                const wallDensity = 0.15 + (gameState.level - 1) * 0.04; // 15% to 51%
                const totalCells = gameState.size * gameState.size;
                const wallCount = Math.floor(totalCells * wallDensity);
                
                // Place walls randomly (but ensure path exists)
                let placedWalls = 0;
                let attempts = 0;
                const maxAttempts = 200;
                
                while (placedWalls < wallCount && attempts < maxAttempts) {
                    const x = Math.floor(Math.random() * gameState.size);
                    const y = Math.floor(Math.random() * gameState.size);
                    
                    // Don't place walls on start or end positions
                    if ((x === gameState.start.x && y === gameState.start.y) || 
                        (x === gameState.end.x && y === gameState.end.y)) {
                        attempts++;
                        continue;
                    }
                    
                    // Temporarily place the wall
                    gameState.maze[y][x] = 1;
                    
                    // Check if path still exists
                    if (pathExists()) {
                        placedWalls++;
                    } else {
                        // Remove the wall if it blocks the path
                        gameState.maze[y][x] = 0;
                    }
                    
                    attempts++;
                }
                
                // Add some decorative walls that don't block the path
                const decorativeWalls = Math.floor(totalCells * 0.05);
                for (let i = 0; i < decorativeWalls; i++) {
                    const x = Math.floor(Math.random() * gameState.size);
                    const y = Math.floor(Math.random() * gameState.size);
                    
                    if (gameState.maze[y][x] === 0 && 
                        !(x === gameState.start.x && y === gameState.start.y) && 
                        !(x === gameState.end.x && y === gameState.end.y)) {
                        gameState.maze[y][x] = 2; // Decorative wall
                    }
                }
                
                // Precompute solution path for this level
                gameState.solution = findSolution();
            }

            // Check if a path exists from start to end
            function pathExists() {
                const visited = Array(gameState.size).fill().map(() => Array(gameState.size).fill(false));
                const queue = [{ ...gameState.start }];
                visited[gameState.start.y][gameState.start.x] = true;
                
                const directions = [
                    { dx: 1, dy: 0 },  // right
                    { dx: -1, dy: 0 }, // left
                    { dx: 0, dy: 1 },  // down
                    { dx: 0, dy: -1 }   // up
                ];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    // Check if we've reached the end
                    if (current.x === gameState.end.x && current.y === gameState.end.y) {
                        return true;
                    }
                    
                    // Explore neighbors
                    for (const dir of directions) {
                        const nx = current.x + dir.dx;
                        const ny = current.y + dir.dy;
                        
                        if (nx >= 0 && nx < gameState.size && ny >= 0 && ny < gameState.size &&
                            !visited[ny][nx] && gameState.maze[ny][nx] !== 1) { // 1 is blocking wall
                            visited[ny][nx] = true;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
                
                return false;
            }

            // Find solution path using BFS
            function findSolution() {
                const visited = Array(gameState.size).fill().map(() => Array(gameState.size).fill(false));
                const queue = [{ ...gameState.start, path: [{ ...gameState.start }] }];
                visited[gameState.start.y][gameState.start.x] = true;
                
                const directions = [
                    { dx: 1, dy: 0 },  // right
                    { dx: -1, dy: 0 }, // left
                    { dx: 0, dy: 1 },  // down
                    { dx: 0, dy: -1 }  // up
                ];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    // Check if we've reached the end
                    if (current.x === gameState.end.x && current.y === gameState.end.y) {
                        return current.path;
                    }
                    
                    // Explore neighbors
                    for (const dir of directions) {
                        const nx = current.x + dir.dx;
                        const ny = current.y + dir.dy;
                        
                        if (nx >= 0 && nx < gameState.size && ny >= 0 && ny < gameState.size &&
                            !visited[ny][nx] && gameState.maze[ny][nx] !== 1) { // 1 is blocking wall
                            visited[ny][nx] = true;
                            const newPath = [...current.path, { x: nx, y: ny }];
                            queue.push({ x: nx, y: ny, path: newPath });
                        }
                    }
                }
                
                return [];
            }

            // Render maze
            function renderMaze() {
                mazeElement.innerHTML = '';
                mazeElement.style.gridTemplateColumns = `repeat(${gameState.size}, 1fr)`;
                mazeElement.style.gridTemplateRows = `repeat(${gameState.size}, 1fr)`;
                
                for (let y = 0; y < gameState.size; y++) {
                    for (let x = 0; x < gameState.size; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        // Set cell classes based on its state
                        if (x === gameState.start.x && y === gameState.start.y) {
                            cell.classList.add('start');
                        } else if (x === gameState.end.x && y === gameState.end.y) {
                            cell.classList.add('end');
                        } else if (gameState.maze[y][x] === 1 || gameState.maze[y][x] === 2) {
                            cell.classList.add('wall');
                        } else if (gameState.path.some(pos => pos.x === x && pos.y === y)) {
                            cell.classList.add('path');
                        } else if (gameState.visited.has(`${x},${y}`)) {
                            cell.classList.add('visited');
                        }
                        
                        if (x === gameState.current.x && y === gameState.current.y) {
                            cell.classList.add('current');
                        }
                        
                        mazeElement.appendChild(cell);
                    }
                }
            }

            // Handle key down
            function handleKeyDown(e) {
                // Don't allow moves while solution is being shown
                if (gameState.solving) return;
                
                // Check if key is already pressed to prevent key repeat
                if (gameState.keyState[e.code]) return;
                gameState.keyState[e.code] = true;
                
                let dx = 0, dy = 0;
                
                if (KEY_CODES.UP.includes(e.code)) {
                    dy = -1;
                } else if (KEY_CODES.DOWN.includes(e.code)) {
                    dy = 1;
                } else if (KEY_CODES.LEFT.includes(e.code)) {
                    dx = -1;
                } else if (KEY_CODES.RIGHT.includes(e.code)) {
                    dx = 1;
                } else {
                    return; // Not a movement key
                }
                
                movePlayer(dx, dy);
            }

            // Handle key up
            function handleKeyUp(e) {
                gameState.keyState[e.code] = false;
            }

            // Handle touch start for swipe controls
            function handleTouchStart(e) {
                if (gameState.solving) {
                    e.preventDefault();
                    return;
                }
                gameState.touchStart = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY,
                    time: Date.now()
                };
            }

            // Handle touch move for swipe controls
            function handleTouchMove(e) {
                if (!gameState.touchStart || gameState.solving) {
                    e.preventDefault();
                    return;
                }
                e.preventDefault();
            }

            // Handle touch end for swipe controls
            function handleTouchEnd(e) {
                if (!gameState.touchStart || gameState.solving) return;
                
                const touchEnd = {
                    x: e.changedTouches[0].clientX,
                    y: e.changedTouches[0].clientY,
                    time: Date.now()
                };
                
                const dx = touchEnd.x - gameState.touchStart.x;
                const dy = touchEnd.y - gameState.touchStart.y;
                const dt = touchEnd.time - gameState.touchStart.time;
                
                // Only consider it a swipe if it's quick enough
                if (dt < 500) {
                    // Determine primary direction
                    if (Math.abs(dx) > Math.abs(dy)) {
                        // Horizontal swipe
                        if (dx > 0) {
                            movePlayer(1, 0); // Right
                        } else {
                            movePlayer(-1, 0); // Left
                        }
                    } else {
                        // Vertical swipe
                        if (dy > 0) {
                            movePlayer(0, 1); // Down
                        } else {
                            movePlayer(0, -1); // Up
                        }
                    }
                }
                
                gameState.touchStart = null;
            }

            // Move player function (handles both keyboard and touch input)
            function movePlayer(dx, dy) {
                if (gameState.solving) return;
                
                // Calculate new position
                const nx = gameState.current.x + dx;
                const ny = gameState.current.y + dy;
                
                // Check if new position is valid
                if (nx >= 0 && nx < gameState.size && ny >= 0 && ny < gameState.size && 
                    gameState.maze[ny][nx] !== 1) { // 1 is blocking wall
                    
                    // Update game state
                    gameState.moves++;
                    gameState.visited.add(`${gameState.current.x},${gameState.current.y}`);
                    gameState.path.push({ ...gameState.current });
                    gameState.current = { x: nx, y: ny };
                    
                    // Check if reached the end
                    if (nx === gameState.end.x && ny === gameState.end.y) {
                        showMessage('Level Complete!', `You solved the maze in ${gameState.moves} moves!`);
                    }
                    
                    updateLevelInfo();
                    renderMaze();
                }
            }

            // Show solution path
            function showSolution() {
                if (gameState.solving || gameState.solution.length === 0) return;
                
                gameState.solving = true;
                solveButton.disabled = true;
                
                // Animate the solution path
                let i = 0;
                const interval = setInterval(() => {
                    if (i < gameState.solution.length) {
                        const pos = gameState.solution[i];
                        gameState.current = { ...pos };
                        gameState.visited.add(`${pos.x},${pos.y}`);
                        renderMaze();
                        i++;
                    } else {
                        clearInterval(interval);
                        gameState.solving = false;
                        solveButton.disabled = false;
                    }
                }, 100);
            }

            // Update level and moves info
            function updateLevelInfo() {
                levelElement.textContent = gameState.level;
                movesElement.textContent = gameState.moves;
            }

            // Show message
            function showMessage(title, text) {
                messageTitle.textContent = title;
                messageText.textContent = text;
                messageElement.classList.add('show');
                overlay.classList.add('show');
                
                if (gameState.level === 10) {
                    nextLevelButton.textContent = 'Play Again';
                    messageTitle.textContent = 'You Win!';
                    messageText.textContent = `Congratulations! You completed all 10 levels with a total of ${gameState.moves} moves!`;
                } else {
                    nextLevelButton.textContent = 'Next Level';
                }
            }

            // Hide message
            function hideMessage() {
                messageElement.classList.remove('show');
                overlay.classList.remove('show');
            }

            // Go to next level
            function nextLevel() {
                hideMessage();
                
                if (gameState.level < 10) {
                    gameState.level++;
                } else {
                    // Reset to level 1 after completing all levels
                    gameState.level = 1;
                }
                
                initGame();
            }
        });
    </script>
</body>
</html>
